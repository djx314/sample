@()
package net.scalax.simple.adt
package impl

import CoreInstance._

@paramType(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } I@{i2} } }
@paramFunc(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } func@{i2}: I@{i2} => T } }
@paramTypeAny(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } Any } }

@forMatch(end: Int, i1: Int) = { @if(i1 > end) { FoldList.zero } else { FoldListPositive(t => new FoldListPositive(t) with TypeAdtGetter {
    override def runGetter: Unit = getValue = func@{i1}.asInstanceOf[Any => Any](data)
}).apply(() => @forMatch(end, i1 + 1)) } }

object InnerTypeAdtClass {
    @for(i1 <- 1 to 22) {
        class CusInnerApply@{i1}[@paramType(1, i1)](adtList: AdtList, data: Any) {
            @@inline def fold[T](@paramFunc(1, i1)): T = {
                var getValue: Any = null
                adtList.apply(() => @{forMatch(i1, 1)})
                getValue.asInstanceOf[T]
            }
        }
        object HelperIOImpl@{i1} extends HelperIO[Any] {
            override type Out = CusInnerApply@{i1}[@paramTypeAny(1, i1)]
            @@inline override def helper(adtList: AdtList, data: Any): CusInnerApply@{i1}[@paramTypeAny(1, i1)] = new CusInnerApply@{i1}(adtList, data)
        }
    }
}