@()
package net.scalax.simple
package adt
package impl

import net.scalax.simple.ghdmzsk.ghdmzsk
import implemention._

@paramType(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } I@{i2} } }
@paramFunc(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } func@{i2}: I@{i2} => T } }
@paramTypeAny(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } Any } }

@forMatch(end: Int, i1: Int) = { @if(i1 > end) { FoldListZero } else {
    FoldListAppender.appendAll(List(@for(n <- i1 to end - 1) { func@{n}.asInstanceOf[Any => Any], } func@{end}.asInstanceOf[Any => Any]))
} }
@buildHList(start: Int, i1: Int) = { @if(start <= i1) {
    NatFuncPositive[I@start, @buildHList(start + 1, i1)]
} else { NatFuncZero } }

object InnerTypeAdtClass {
    @for(i1 <- 1 to 22) {
        class PrepareInnerApply@{i1}[@paramType(1, i1)] {
            @@inline def apply[T](data: T)(implicit v: net.scalax.simple.adt.TypeAdtApply.Aux[T, @buildHList(1, i1), Adt.Status.Passed]): FoldNatPositiveHelper.FoldNatPositiveHelperWrap@{i1}[@paramType(1, i1)] = {
                val dataInstance = v.value(data)
                new FoldNatPositiveHelper.FoldNatPositiveHelperWrap@{i1}(dataInstance.dataInstance, dataInstance.tail)
            }
        }
        object HelperIOImpl@{i1} extends PrepareInnerApply@{i1}[@paramTypeAny(1, i1)]
    }
}