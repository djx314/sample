@()
package net.scalax.simple.adt
package impl

import implemention._

@paramType(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } I@{i2} } }
@classNameForPositive(i1: Int, sum: Int) = { @if(i1 <= sum) { NatFuncPositive[T@{i1}, @classNameForPositive(i1 + 1, sum)] } else { NatFuncZero } }
@foldPararmeters(count: Int) = { @for(c <- 1 to count) { @if(c > 1) { , } func@{c}: T@{c} => U } }
@foldBody(count: Int) = {
    @if(count > 1) { @foldBody(count - 1) }

    .overrideOnce(this@for(x <- 1 to count - 1) { .tail })(func@{count})
}

trait FoldNatPositiveHelper {


    @for(i1 <- 1 to 22) {
        class FoldNatPositiveHelperWrap@{i1}[@for(i2 <- 1 to i1) { @if(i2 > 1) { , } T@{i2} }](override val dataInstance: Option[T1], override val tail: @classNameForPositive(2, i1)) extends @classNameForPositive(1, i1) (dataInstance) {
            def foldOpt[U](@foldPararmeters(i1)): Option[U] = {
                FoldContext.empty
                @foldBody(i1)
                .option
            }
            def fold[U](@foldPararmeters(i1)): U = foldOpt(func1 @for(ix <- 2 to i1) { , func@{ix} }).get
        }
    }
}

object FoldNatPositiveHelper extends FoldNatPositiveHelper