@()
package net.scalax.simple.adt
package impl

import net.scalax.simple.ghdmzsk.ghdmzsk

import implemention._
import net.scalax.simple.adt.{ TypeAdt => InnerAdt }

@paramType(start: Int, i1: Int) = { @for(i2 <- start to i1) { @if(i2 > start){ , } I@{i2} } }
@classNameForPositive(i1: Int, sum: Int) = { @if(i1 <= sum) { NatFuncPositive[T@{i1}, @classNameForPositive(i1 + 1, sum)] } else { NatFuncZero } }
@foldPararmeters(count: Int) = { @for(c <- 1 to count) { @if(c > 1) { , } func@{c}: T@{c} => U } }
@foldPararmetersInstance(count: Int) = { @for(c <- 1 to count) { @if(c > 1) { , } func@{c} } }

object FoldNatPositiveHelper {

    @for(i1 <- 1 to 22) {
        abstract class FoldNatPositiveHelperWrap@{i1}[@for(i2 <- 1 to i1) { @if(i2 > 1) { , } T@{i2} }](override val dataInstance: Option[T1], override val isAlreadyOk: Boolean, override val tail: @classNameForPositive(2, i1)) extends @classNameForPositive(1, i1) (dataInstance) {
            def dataImpl: Any
            def fold[U](@foldPararmeters(i1)): U = {
                val dataModel = dataImpl
                val funcs = List(@foldPararmetersInstance(i1))
                val listFunc: ghdmzsk = TypeAdtGetter.fromList(funcs.asInstanceOf[List[Any => Any]])
                val data: (Any, Int) = dataModel.asInstanceOf[(Any, Int)]
                val funcInstance = this.inputGHDMZSK(Disscure.takeHead).inputGHDMZSK(listFunc).asInstanceOf[Disscure.GetValue].value.asInstanceOf[Any => U]
                funcInstance(data._1)
            }
        }
    }

}