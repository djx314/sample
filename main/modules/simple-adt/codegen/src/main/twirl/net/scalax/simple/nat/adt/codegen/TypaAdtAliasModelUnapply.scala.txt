@()
package net.scalax.simple
package adt
package impl

import implemention._

@buildHList(start: Int, i1: Int) = {
    @if(start <= i1) {
        NatFuncPositive[I@start, @buildHList(start + 1, i1)]
    } else {
        Tail
    }
}

@buildHListString(i1: Int) = {
    @if(i1 > 0) {
        net.scalax.simple.adt.implemention.UnapplyInstance.PositiveTypeCounter[@buildHListString(i1 - 1)]
    } else {
        net.scalax.simple.adt.implemention.UnapplyInstance.PositiveTypeCounterZero
    }
}
@buildHListInstance(i1: Int) = {
    @if(i1 > 0) {
        net.scalax.simple.adt.implemention.UnapplyInstance.PositiveTypeCounter(@buildHListInstance(i1 - 1))
    } else {
        net.scalax.simple.adt.implemention.UnapplyInstance.PositiveTypeCounterZero.value
    }
}

trait TypeAdtAliasModelUnapply {
    @for(i1 <- 1 to 30) {
        type OptionNat@{i1} = @buildHListString(i1 - 1)
        val OptionNat@{i1} = @buildHListInstance(i1 - 1)
    }


    @for(i1 <- 1 to 30) {
        val Option@{i1}: net.scalax.simple.adt.implemention.UnapplyInstance.UnapplyFunc[OptionNat@{i1}] = net.scalax.simple.adt.implemention.UnapplyInstance.UnapplyFunc(OptionNat@{i1})
    }
}