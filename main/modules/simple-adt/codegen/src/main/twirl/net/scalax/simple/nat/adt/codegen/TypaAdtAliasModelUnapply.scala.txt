@()
package net.scalax.simple
package adt
package impl

import net.scalax.simple.adt.implemention.{ UnapplyInstance => UI, NatFuncPositive, NatFunc }
import UI.{ UnapplyFuncPositive => UFP, CountNatPositive => CP, PositiveTypeCounter => PC }

trait TypeAdtAliasModelUnapply {
    import TypeAdtAliasModelUnapplyImpl._
    val Option1: UI.UnapplyFuncZero = OptionNatImpl1.value
    @for(i1 <- 2 to 30) {
        val Option@{i1}: OptionNatImpl@{i1} = OptionNatImpl@{i1}.value
    }
}

object TypeAdtAliasModelUnapplyImpl {

    type OptionNatImpl1 = UI.UnapplyFuncZero
    object OptionNatImpl1 {
        val value: OptionNatImpl1 = UI.UnapplyFuncZero.value
    }

    @for(i1 <- 2 to 30) {
        class OptionNatImpl@{i1} extends UFP[OptionNatImpl@{i1 - 1}] with PC[OptionNatImpl@{i1 - 1}] {
            self =>
            override type ThisType = OptionNatImpl@{i1}
            override val tail: OptionNatImpl@{i1 - 1} = OptionNatImpl@{i1 - 1}.value
            override def apply[U <: NatFunc, Data](u: U)(implicit somethig_not_used: CP.Aux[OptionNatImpl@{i1}, U, Data]): Option[Data] = super.apply(u)
            override def unapply[U <: NatFunc, Data](u: U)(implicit somethig_not_used: CP.Aux[OptionNatImpl@{i1}, U, Data]): Option[Data] = super.unapply(u)
        }
        object OptionNatImpl@{i1} {
            val value: OptionNatImpl@{i1} = new OptionNatImpl@{i1}

            implicit def positiveGetTail[T2Tail <: NatFunc, Data, TempData](implicit
                somethig_not_used: CP.Aux[OptionNatImpl@{i1 - 1}, T2Tail, Data]
            ): CP.Aux[OptionNatImpl@{i1}, NatFuncPositive[TempData, T2Tail], Data] =
                new CP[OptionNatImpl@{i1}, NatFuncPositive[TempData, T2Tail]] {
                    override type DataType = Data
                    override def index: Int = @{i1 - 1}
                }
        }
    }
}